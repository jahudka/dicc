# Services and dependencies

There are two distinct tasks you'll need to tackle in order to use DICC in your
project: you'll need to code your services (duh) and you'll need to provide
definitions to the DICC compiler. We'll look at service definitions first.


## Defining services

Simple services, which don't require any special options and whose dependencies
can be resolved automatically by the compiler, need only to be discoverable by
the compiler as exports from one of the resource files:

```typescript
// this will register the ServiceOne class as a service and it will also
// automatically include any interfaces ServiceOne implements, as well as
// its ancestors and their interfaces, as aliases:
export { ServiceOne } from '../services';

// assuming ServiceTwoInterface is actually an interface, this will register
// a dynamic service of the ServiceTwoInterface type; any other interfaces which
// ServiceTwoInterface implements will be registered as its aliases:
export { ServiceTwoInterface } from '../services';
```

There is a special case for classes which don't have any public constructors,
but which have a static `create()` method: if such a class is found, it will be
registered and the `create()` method will be used at runtime as the service
factory.

Services registered this way will not have a public service ID. They will have
autogenerated string identifiers beginning with a `#` character, but you're
strongly discouraged from using them, because they're a product of the
compilation process and can change at any time, even between compilations in
some cases. Instead, you should rely on injection to get instances of these
services. You know, the thing you're using this library for.

When you need to do some more complex logic to create a service instance, or
when you want to provide other service configuration such as a scope or one or
more service hooks, you can export a _service definition_ from a resource file.

As briefly mentioned before, a service definition is a special `satisfies`
expression. This is what it looks like:

```typescript
import { ServiceDefinition } from 'dicc';

// the simplest kind of definition - an instantiable class service;
// note that this would be almost equivalent to just `export { ServiceOne }`,
// except that no aliases are automatically registered:
export const one = ServiceOne satisfies ServiceDefinition<ServiceOne>;

// a definition with an alias:
export const twoWithOneAlias = ServiceTwo satisfies ServiceDefinition<ServiceTwo, AliasOne>;
// multiple aliases can be specified as a tuple:
export const twoWithMultipleAliases = ServiceTwo satisfies ServiceDefinition<ServiceTwo, [AliasOne, AliasTwo]>;

// a definition using a factory function:
export const three = (() => new ServiceThree()) satisfies ServiceDefinition<ServiceThree>;
export const alsoThree = ServiceThree.create satisfies ServiceDefinition<ServiceThree>;

// a definition using an object literal, allowing us to specify other options:
export const four = {
  factory: ServiceFour,
  onCreate() { console.log('Four created!') },
} satisfies ServiceDefinition<ServiceFour>;

// a factory function can be async:
export const five = (async () => new ServiceFive()) satisfies ServiceDefinition<ServiceFive>;
export const alsoFive = {
  async factory() { return new ServiceFive() },
  onCreate(service) { console.log(`Five says: ${service.sayHello()}`) }
} satisfies ServiceDefinition<ServiceFive>;

// factories may return undefined if a service cannot be created:
export const maybeSix = (
  () => process.env.WITH_SIX ? new ServiceSix() : undefined
) satisfies ServiceDefinition<ServiceSix>;

// factories themselves can be undefined - this makes the service dynamic,
// that is, the compiler can include code to inject it as a dependency to other
// services, but the runtime container can't create it and instead you need to
// register it manually:
export const seven = undefined satisfies ServiceDefinition<ServiceSeven>;
export const alsoSeven = {
  factory: undefined,
  onCreate() { console.log('Seven registered in the container!') },
} satisfies ServiceDefinition<ServiceSeven>;
```

A definition file can re-export definitions from other files:

```typescript
// logger.ts
export const logger = { ...definition };

// orm.ts
export const repository = {
  author: { ...definition },
  book: { ...definition },
};

// controllers/admin.ts
export namespace controllers {
  export const createBook = { ...definition };
  export const deleteBook = { ...definition };
}

// controllers/public.ts
export namespace controllers {
  export const listBooks = { ...definition };
}

// controllers/index.ts
export * from './admin';
export * from './public';

// definitions.ts
export * from './logger';
export * as orm from './orm';
export * from './controllers';

// exported service definition tree would look like this:
const defs = {
  logger: { ...definition },
  orm: {
    repository: {
      author: { ...definition },
      book: { ...definition },
    },
  },
  controllers: {
    createBook: { ...definition },
    deleteBook: { ...definition },
    listBooks: { ...definition },
  },
};

// this, in turn, would result in the following flattened service IDs:
container.get('logger');
container.get('orm.repository.author');
container.get('controllers.listBooks');
// etc
```

Now that we know how to tell DICC about services, let's see how we can tell it
what those services depend on.


## Injecting dependencies

As explained in the previous sections, DICC will analyse the constructor or
factory of each defined service and attempt to inject the correct values into
its arguments when the service is being created. There are several ways services
can depend on other services. We'll explore all the options using some examples.
The first thing we'll look at is simply injecting a single instance of a
dependency directly. We can assume that the appropriate service definitions for
all the service classes in the following snippet exist, they're not important
here:

```typescript
// no constructor, or a constructor with no arguments, means no dependencies
export class ServiceOne {}

// a similar example, but with an async factory, making ServiceTwo async:
export class ServiceTwo {
  static async create(): Promise<ServiceTwo> {
    return new ServiceTwo();
  }
}

// ServiceThree depends on both services directly - it doesn't care if either
// service it depends on is async, it just wants the resolved instances; the
// compiled factory for ServiceThree would therefore be async in order to be
// able to resolve the promise for ServiceTwo, but ServiceThree itself doesn't
// need to know or care:
export class ServiceThree {
  constructor(
    readonly one: ServiceOne,
    readonly two: ServiceTwo,
  ) {}
}

// ServiceFour is an example where a promise for ServiceTwo needs to be injected
// and it's then ServiceFour's job to await it when it needs access to the
// ServiceTwo instance; it adds some complexity to ServiceFour, but it means
// that it can be created synchronously, even though it depends on an async
// service:
export class ServiceFour {
  constructor(readonly two: Promise<ServiceTwo>) {}
}

// ServiceFive shows an example of depending on optional services.
// Let's first imagine an optional service:
export class ServiceBar {
  create(): ServiceBar | undefined {
    return process.env.WITH_BAR ? new ServiceBar() : undefined;
  }
}

export class ServiceFive {
  constructor(
    readonly one?: ServiceOne, // would inject ServiceOne
    readonly foo?: ServiceFoo, // would inject undefined - no such service exists
    readonly bar?: ServiceBar, // would inject ServiceBar | undefined
                               // based on what ServiceBar.create() returns
  ) {}
}
```

This covers the most common and most simple injection modes, but DICC can do
a lot more than that. For example, you can depend on an _accessor_ for a
service - a callback with no arguments which will return the requested service.
This can be useful to break cyclic dependencies (an accessor is not a direct
dependency), or to let a potentially heavy service be initialised lazily only
when it's needed:

```typescript
export class ServiceFive {
  constructor(
    readonly getOne: () => ServiceOne,
    readonly getTwo: () => Promise<ServiceTwo>, // accessor for an async service
  ) {}
}
```

We've mentioned dynamic services before - services whose type the compiler knows
(and therefore can autowire as dependencies into other services), but which the
runtime container cannot create, relying instead on your code to register the
service instance when appropriate. This may induce you to think that *some*
part of your code would indeed need to know that there is a DI container, in
order to register the dynamic service into the container. But fear not! DICC has
even that base covered: similarly to service accessors, you can have DICC inject
a so-called _service injector_, which is a callback accepting a single typed
argument and returning `void`, like this:

```typescript
export class RequestDispatcher {
  constructor(
    readonly registerHttpRequest: (request: HttpRequest) => void,
  ) {}

  dispatch(request: HttpRequest): void {
    this.registerHttpRequest(request);
    // now the dynamic service HttpReqeuest is properly registered
    // in the container
  }
}
```

Another thing DICC allows you to do is define (directly or via aliases)
multiple services of the same type and then to inject all services of a given
type as an array:

```typescript
export interface Logger {
  log(message: string): void;
}

// in definitions.ts you would add the Logger interface as an alias
// to both of the following services:
export class ConsoleLogger {
  log(message: string): void {
    console.log(message);
  }
}

export class FileLogger {
  private readonly file: WritableStream;

  log(message: string): void {
    this.file.getWriter().write(message);
  }
}

// AggregatedLogger will get all the services with the Logger alias;
// note that it mustn't be given the Logger alias itself, as that would
// make the container attempt to inject it into itself, which would fail:
export class AggregatedLogger {
  constructor(private readonly loggers: Logger[]) {}

  log(message: string): void {
    for (const logger of this.loggers) {
      logger.log(message);
    }
  }
}
```

If one or more of the services of the type you wish to inject is async, you
can ask DICC to inject a Promise for the array, e.g.:

```typescript
export class AggregatedLogger {
  constructor(private readonly loggers: Promise<Logger[]>) {}
}
```

You can combine accessor and array injection:

```typescript
export class AggregatedLogger {
  constructor(
    // for sync services:
    private readonly getLoggers: () => Logger[],
    // if one or more of the services is async:
    private readonly getLoggersAsync: () => Promise<Logger[]>,
  ) {}
}
```

Last, but not least, you can inject _iterables_ - this also allows you to inject
a bunch of services of the same type, but unlike injecting an array (or an
accessor for an array), each service in the iterable will be lazily resolved
when the iterable reaches it. Works for sync and async services:

```typescript
export class AggregatedLogger {
  constructor(
    // for sync services:
    private readonly loggers: Iterable<Logger>,
    // if one or more of the services is async:
    private readonly asyncLoggers: AsyncIterable<Logger>,
  ) {}
}
```

Note that accessors and iterables in combination with async services can break
one of the core DI concepts - that services shouldn't care how their
dependencies are created. If you need to inject an accessor or an iterable, you
need to know whether (one or more of) the injected service(s) is async - e.g.
service X, which needs to have an accessor for service Y, needs to type the
accessor according to the definition (and dependencies) of service Y - the
accessor must either return `Y`, or `Promise<Y>`, but X shouldn't have to deal
with that. But I don't know of any mechanism which could circumvent this. At
least it isn't a dependency on the DI framework itself - the requirement to
appropriately pick whether X should depend on `() => Y` or `() => Promise<Y>`
arises from application code, and as far as I can tell, there is no way this
could be resolved in _any_ framework which allows async services (well, not
unless other contracts are broken - such as accessors and iterables being lazy,
which seems like a more important feature). In any case, you don't have to
_think_ about it too much, because DICC will throw an error during compilation
if you try to inject a non-async accessor or iterable for something which _is_
async.


## Tags

Occasionally it might be useful to be able for a service which depends on
a number of other services to have some information about the dependencies prior
to accessing them, in order to be able to initialize select dependencies lazily.
You can use _service tags_ for this. Service tags are key-value pairs; the keys
must be strings, but the values can be anything. Tags are specified in a service
definition object, same as scope and hooks:

```typescript
export const getAuthorsResolver = {
  factory: GetAuthorsResolver,
  tags: {
    'graphql.resolver': { type: 'query', operation: 'getAuthors' },
  },
} satisfies ServiceDefinition<GetAuthorsResolver, GraphQLResolverInterface>;

// you can then inject services based on tags;
// the injected value is a list of [tag value, service accessor] pairs:
export const schemaRoot = {
  factory: (di: Container) => new SchemaRoot(di.findByTag('graphql.resolver')),
} satisfies ServiceDefinition<SchemaRoot>;

// in SchemaRoot:
export class SchemaRoot {
  constructor(resolvers: [tagValue: any, serviceAccessor: () => unknown][]) {}
}
```

Currently, tags suffer from two downsides: they aren't typed, meaning that the
return value of `di.findByTag()` is `[any, () => unknown][]`, and that means you
need to do some type checking when you consume them; and second, they cannot be
injected automatically - you have to inject the container itself into the
service factory and manually call its `findByTag()` method. There will probably
be a better way to do this in the future, this is just a first implementation.


## Service decorators

The service decorator pattern can be used to augment existing service
definitions without actually modifying their code. In DICC, you can use service
decorators to change services' scope, add additional lifecycle hooks, and even
to wrap service factories with callbacks, giving you access to - and control
over - service instances before they're registered in the container. Let's take
a look at an example - imagine we have a bunch of services implementing a common
interface defined somewhere, and we want to change all of their scopes to
`private`:

```typescript
import { ServiceDecorator } from 'dicc';

export const setCommonScope = {
  scope: 'private',
} satisfies ServiceDecorator<CommonInterface>;
```

If you look at the compiled container, in this case the decorator won't be
referenced anywhere explicitly, because the compiler can simply set the `scope`
property of the affected services directly. But what if you wanted to add an
`onCreate` hook in order to get notified when one of the target services is
created?

```typescript
export const notifyCreated = {
  // 'service' is correctly typed as a 'CommonInterface' instance, courtesy of
  // the 'satisfies' expression; 'logger' will be injected by the compiler:
  onCreate(service, logger: LoggerInterface) {
    logger.log('CommonInterface instance created!', service);
  },
} satisfies ServiceDecorator<CommonInterface>;
```

Service decorators can add any of the three service lifecycle hooks; the
`onCreate` and `onDestroy` hooks follow the same semantics as if they were
registered on the service definitions, but the `onFork` hook works slightly
differently: if the service definition has an `onFork` hook which returns a
forked instance of the service, all the service's decorators will receive that
instance instead of the original service, and the decorators' `onFork` hooks'
return values are ignored, meaning a decorator's `onFork` hook cannot be used
to create a forked service instance.

Service decorators can also be applied to the output of service factories:

```typescript
export const withLoggedMethodCalls = {
  decorate(service, logger: MethodCallLoggerInterface) {
    return new Proxy(service, logger.createProxyHandlers(service));
  },
} satisfies ServiceDecorator<SomeInterface>;
```

Currently, the `decorate` hook must return either an instance of the same class
as the original service which was passed in, or a `Proxy` for the same. In the
future, decorators might possibly be given the ability to completely override
the service's type, although I will have to think hard on all the ramifications
of such a capability.


**Next**: [Config and compilation][1]

[1]: user/04-config-and-compilation.md
